# 面向对象
## 面向对象 VS 面向过程
   1. 面向对象适合处理复杂、多协作的业务逻辑
   2. 面向过程适合简单，协作较少的业务逻辑
## 类 & 对象
   ```
   public class Student {
    long id;
    String name;
    int age;
    static String city = "china";
    static int count = 0;
    static {
    	System.out.print("static init area");
    	count++;
    }
    public static void main(String[] args) {
    	Student stu = new Student(18);
    	stu.say("java\n");
    	fn();
    }
    Student(int age){
    	this.age = age;
    	this.id = System.currentTimeMillis();
    	System.out.print("构造函数\n");
    	count++;
    }
    void say(String name) {
    	this.name = name;
    	System.out.print(this.id + "\n");
    	count++;
    }
    static void fn() {
    	System.out.print(count);
    	count++;
    	System.out.print(count);
    }
   }
   ```
   1. 注意事项
      + 静态方法里不能访问成员变量和成员方法
      + 静态方法里只能访问静态变量和静态方法
      + 静态方法里不能访问 this
   2. 静态初始化块
      + 在实例初始化的时候调用，先于构造器调用
   ```
   static {
       System.out.print("init static");
   }
   ```
## 值传递
```
public class Transform {
	String name;
	int age;
	public static void main(String[] args) {
		Transform obj = new Transform("java",20);
		obj.updateName(obj);
		System.out.print(obj.name);
	}
	Transform(String name,int age){
		this.name = name;
		this.age = age;
	}
	void updateName(Transform u) {
		u.name = "PHP";
	}
	void updateAge() {
		this.age = 18;
	}
}
```
## 包机制
   + 解决类重名的问题，类似于文件夹的功能
   + package chat.zyb.study;
   + 每个类开头都要先加包名，功能类似于PHP中的命名空间
   + 同一个包的类不需要导入就可以直接使用
   + 不同包的类需要导入才能使用
   + 导入包中的某个类  import cn.zyb.study.Test;
   + 导入包中的所有类  import cn.zyb.test.*;
   + 包与包之间不能嵌套
   + 包之间存在同名的类 import cn.zyb.study.Test = new cn.zyb.study.Test()
   + 导入静态属性 import java.lang.Math.PI |　import java.lang.Math.*; 
## 面向对象的特性
   + 封装
   + 继承
      1. extends
      2. 子类在实例化的时候会执行父类的静态初始化块的代码和父类构造器方法
      3. java是单继承语言，PHP也是单继承语言，java的接口可以多继承
      4. 所有的类如果没有显式的继承某个父类，则默认是继承Oject类
      5. ctrl+T 可以看到类的继承树结构
      6. a instanceof A 检测a是否是A的实例，继承树上的任何类都返回true
      7. 如果父类有有参构造方法，子类在继承时必须在构造方法中调用父类构造方法,super(参数    列表)
      8. 如果父类的构造方法是无参的，则不需要显式调用
      9. 继承实现的过程：先实例化父类再实例化子类
      ```
        package cn.zyb.oop;
        public class TestExtends {
            public static void main(String[] args) {
                Student stu = new Student("java");
                System.out.print(stu.country + "\n");
		        stu.rest();
            }
        }
        class Test extends Student{
            Test(){
                super("php"); // super方法必须在其他代码之前实现
                this.name = "111";
            }
        }
        class Person{
            String name = "test_name";
            int age = 18;
            String country;
            static {
                System.out.print("有子类继承了我，并执行了我的静态初始化块的代码\n");
            }
            Person(){
                System.out.print("有子类继承了我，并执行了我的构造器方法\n");
                this.country = "China";
            }
            void rest() {
                System.out.print("rest");
            }
        }
        class Student extends Person{
            String major;
            Student(String major){
                this.major = major;
            }
        }
      ```
   + 多态
## 方法的重写
   + 子类重写父类的方法
   + 方法名和形参列表保持一致，如果不一致会实现方法的重载
   + 子类返回值要小于等于父类
      1. 如果返回实例，注意继承树的父子结构，父类实例>子类实例
      2. 如果返回基本数据类型，注意返回值的类型必须相同
   + 子类的访问权限要大于等于父类
## Object类
   + 重写 toString & equals
   ```
    package cn.zyb.oop;
    public class TestObject {
        public static void main(String[] args) {
            TestObject obj = new TestObject();
            System.out.print(obj.toString());
            boolean res = obj.equals(obj);
            System.out.print(res);
        }
        public String toString() {
            return "override";
        }
        public boolean equals(TestObject obj) {
            return this==obj;
        }
    }
   ```
## super关键字
   + 子类必须在构造器中调用父类的有参构造器
   + 通过 super可以调用父类实例的属性和方法
   + 在子类中super代表的就是父类的实例
```
package cn.zyb.oop;
public class TestSuper {
    public static void main(String[] args) {
    	Son obj = new Son();
    	obj.fn();
    }
}
class Father{
	public int value = 100;
	void fn() {
		System.out.print(this.value);
	}
	Father(String name){
		System.out.print(name);
	}
}
class Son extends Father{
	public int value = 200;
	Son(){
		super("son");
		super.fn();
	}
	void fn() {
		super.fn();
		System.out.print(this.value);
		System.out.print(super.value);
	}
}
```
## 封装
   1. 高内聚、低耦合
   2. 访问控制符：限制访问权限
   3. 没有用public修饰的类在其他类中不能访问
   4. 一个文件只能有一个 public 类
   ![访问权限](/img/java-permission.jpg)
      + public: 所有包中的所有类都可以访问
      + protected: 同一个包中的类以及其他包中的子类能访问
      + private: 自己只有类能访问
      + default: 没有修饰符，只能同一个包的类能访问
   5. 使用规范
      1. 对于类的属性，一般使用 private
      2. 对于类属性的修改，提供set方法
      3. 对于属性的获取，提供get方法
      ```
      public class Permission{
        private int id;
        private String name;
        private String height;
        public void setName(String name) {
            <!-- this.name = name; -->
            return name;
        }
        public void setHeight(String height) {
            this.height = height;
        }
        public String getName(){
            return this.name;
        }
        public static void main(String[] args) {
            Permission obj = new Permission();
            obj.setName("java");
            System.out.print(obj.name + "\n");
        }
      } 
      ```
## 多态
   + 实现多态的三个条件
      1. 必须要有继承
      2. 方法要重写
      3. 父类引用指向子类实例
```
public class TestPolym {
    public static void main(String[] args) {
    	Animal a = new Animal();
    	animalCry(a);
    	Dog d = new Dog();
    	animalCry(d);
    	Cat c = new Cat();
    	animalCry(c);
    }
    static void animalCry(Animal a) {
    	a.cry();
    }
}
class Animal{
	public void cry() {
		System.out.print("animal\n");
	}
}
class Dog extends Animal{
	public void cry() {
		System.out.print("dog\n");
	}
}
class Cat extends Animal{
	public void cry() {
		System.out.print("cat\n");
	}
}
```
## 对象的转型
```
class Animal{
	public void cry() {
		System.out.print("animal\n");
	}
}
class Dog extends Animal{
	public void cry() {
		System.out.print("dog\n");
	}
    public void seeDoor() {
		System.out.print("see door");
	}
}
Animal dog = new Dog(); // 自动向下转型
dog不能调用seeDoor方法
Dog dog2 = (Dog)dog; // 强制转型
dog2可以调用seeDoor方法
dog.cry(); => dog // 如果Dog类中没有cry方法则调用Animal中的方法，否则调用Dog中的方法
```
## final关键字
   1. 可以修饰变量、方法、类
   2. final修饰的变量不能被修改
   3. final修饰的方法不能被重写，但可以重载
   4. final修饰的类不能被继承