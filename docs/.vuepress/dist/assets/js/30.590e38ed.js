(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{177:function(e,n,a){"use strict";a.r(n);var s=a(0),t=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),a("h2",{attrs:{id:"set-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-map","aria-hidden":"true"}},[e._v("#")]),e._v(" Set & Map")]),e._v(" "),a("h3",{attrs:{id:"set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set","aria-hidden":"true"}},[e._v("#")]),e._v(" Set")]),e._v(" "),a("ul",[a("li",[e._v("ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值")]),e._v(" "),a("li",[e._v("new Set(params) params可选，且必须是array")]),e._v(" "),a("li",[e._v("Set实例的本质是一个数组，可以调用数组的方法")]),e._v(" "),a("li",[e._v("Set方法最大的方便就是可以去重基本数据类型组成的数组")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const arr = new Set([1,2,3,4,5,1,2])\nconsole.log(arr) // => [1,2,3,4,5]\nconst friends = new Set([\n        {name:"sunwukong",age:500},\n        {name:"zhubajie",age:600},\n        {name:"shaheshang",age:700},\n        {name:"sunwukong",age:500}\n    ])\nconsole.log(friends.length) // => 4 引用数据类型无法去重  \n')])])]),a("ul",[a("li",[e._v("Set实例方法\n"),a("ol",[a("li",[e._v("add(value) ->添加某个值，返回Set结构本身")]),e._v(" "),a("li",[e._v("delete(value) ->删除某个值，返回一个布尔值，表示删除是否成功")]),e._v(" "),a("li",[e._v("has(value) ->返回一个布尔值，表示该值是否为Set的成员")]),e._v(" "),a("li",[e._v("clear() ->清除所有成员，没有返回值")])])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("注意：has & delete 无法操作引用数据类型\n")])])]),a("h3",{attrs:{id:"map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map","aria-hidden":"true"}},[e._v("#")]),e._v(" Map")]),e._v(" "),a("ul",[a("li",[e._v("ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型   的值（包括对象）都可以当作键")]),e._v(" "),a("li",[e._v("Map构造函数接受数组作为参数")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const items = [\n  ['name', '张三'],\n  ['title', 'Author']\n]\nconst map = new Map();\nitems.forEach(\n  ([key, value]) => map.set(key, value)\n)\n")])])]),a("h2",{attrs:{id:"async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await","aria-hidden":"true"}},[e._v("#")]),e._v(" async/await")]),e._v(" "),a("ul",[a("li",[e._v("async")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function fn1(){\n    return 'res'\n}\nconst result = fn1()\nresult.then(arg=>{\n    console.log(arg)  // 'res'\n})\n总结：1. async修饰的函数，返回值会被包装成一个Promise对象\n     2. async修饰函数，相当于 return new Promise((resolve,reject)=>{}) 的语法糖\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function fn1(){\n    return 'fn1'\n}\nasync function fn2(){\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('fn2')\n        },2000)\n    })\n}\nfunction fn3(){\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('fn3')\n        },1000)\n    })\n}\nconst result = fn1()\nresult.then(res=>{\n    console.log(res)\n    return fn2()\n}).then(res=>{\n    console.log(res)\n    return fn3()\n}).then(res=>{\n    console.log(res)\n})\n执行结果:fn1->fn2->fn3\n")])])]),a("ul",[a("li",[e._v("await")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function fn2(){\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('fn2')\n        },2000)\n    })\n}\nfunction fn3(){\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('fn3')\n        },1000)\n    })\n}\nasync function fn1(){\n    console.time('out')\n    const res2 = await fn2()\n    const res3 = await fn3()\n    console.log(res2,res3) // 3s后输出 => fn2 fn3\n    console.timeEnd('out')\n    const res4 = await Promise.all([fn2(),fn3()])\n    console.log(res4) // 6s后输出 => ['fn2','fn3']\n    const res5 = await Promise.race([fn2(),fn3()])\n    console.log(res5) // 7s后输出 => fn3\n}\nfn1() \n总结: 1. await必须在async内部定义\n     2. await 等待的必须是实例化Promise对象，得到的结果是resolve接收的值\n     3. Promise.all等待最后一个Promise执行完成，把所有执行结果放在数组里\n     4. Promise.race 将最先执行完成的结果输出,其他的Promisea仍然在执行，但执行结果不会放到res5\n")])])])])}],!1,null,null,null);t.options.__file="es6.md";n.default=t.exports}}]);